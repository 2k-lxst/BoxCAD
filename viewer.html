<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoxCAD Local STL Viewer</title>

    <style>
        /* Loader */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #212121;
            -webkit-user-select: none;
            user-select: none;
            -webkit-user-drag: none;
        }

        canvas {
            display: block;
        }

        #loader-container {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: radial-gradient(circle, #272727 0%, #111111 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.8s ease-out;
            overflow: hidden;
        }

        #loader-container::before {
            content: "";
            position: absolute;
            inset: 0;
            background-image:
                repeating-linear-gradient(
                    0deg,
                    rgba(255, 255, 255, 0.025),
                    rgba(255, 255, 255, 0.025) 1px,
                    transparent 1px,
                    transparent 40px
                ),

                repeating-linear-gradient(
                    90deg,
                    rgba(255, 255, 255, 0.025),
                    rgba(255, 255, 255, 0.025) 1px,
                    transparent 1px,
                    transparent 40px
                );
            mask-image: radial-gradient(
                circle at center,
                transparent 0%,
                black 70%
            );
            animation: gridDrift 10s linear infinite;
            pointer-events: none;
            z-index: 0;
        }

        .loader-content {
            position: relative;
            z-index: 1;
        }

        .ring-loader {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top: 4px solid #ffffff;
            animation: spin 1.5s cubic-bezier(0.4, 0, 0.2, 1) infinite;
        }

        .loader-text {
            margin-top: 17px;
            color: rgba(255, 255, 255, 0.8);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-weight: 500;
            font-size: 14px;
            letter-spacing: 0.1em;
            opacity: 0.9;
            animation: pulse 1.5s infinite ease-in-out;
        }

        /* Settings menu */
        #ui-container {
            position: absolute;
            top: 15px;
            right: 15px;
            font-family: "Segoe UI", sans-serif;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            pointer-events: none;
        }

        #menu-button {
            display: flex;
            opacity: 0;
            pointer-events: auto;
            font-size: 22px;
            line-height: 1;
            background: rgba(50, 50, 50, 0.8);
            transform-origin: center;
            width: 42px;
            height: 42px;
            min-width: 42px;
            color: white;
            border: none;
            padding: 7px 14px;
            border-radius: 5px;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            transition: background 0.3s ease,
                font-size 0.2s ease,
                transform 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.5s ease;
        }

        #menu-button.is-open {
            background-color: #ec3750;
        }

        #menu-button.is-ready {
            opacity: 1;
            pointer-events: auto;
        }

        #menu-button:active {
            transform: scale(0.9);
        }

        #settings-menu {
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            margin-top: 10px;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            width: 200px;
            transform-origin: top right;
            transition:
                opacity 0.17s cubic-bezier(0.4, 0, 0.2, 1),
                transform 0.17s cubic-bezier(0.4, 0, 0.2, 1),
                visibility 0.17s;
            opacity: 1;
            transform: translateY(0) scale(1);
            visibility: visible;
            pointer-events: auto;
        }

        #settings-menu.hidden {
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px) scale(0.8);
            pointer-events: none;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 13px;
        }

        h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }

        #reset-cam {
            width: 100%;
            margin-top: 5px;
            cursor: pointer;
            background: #ec3750;
            color: white;
            border: none;
            padding: 5px;
            border-radius: 4px;
        }

        /* Measurement label */
        /* .measurement-label {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
            font-family: sans-serif;
            pointer-events: none;
            white-space: nowrap;
        } */

        /* Animations */
        @keyframes rotate {
            0% { transform: rotate(0deg); border-color: #007acc; }
            50% { transform: rotate(180deg); border-color: #4fc3f7; transform: scale(1.2); }
            100% { transform: rotate(360deg); border-color: #007acc; }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); }
            50% { opacity: 0.5; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); opacity: 1; }
            50% { opacity: 0.3; }
            100% { transform: rotate(360deg); opacity: 1; }
        }

        @keyframes gridDrift {
            from { background-position: 0 0; }
            to { background-position: 40px -40px; }
        }
    </style>
</head>

<body>
    <div id="loader-container">
        <div class="loader-content" style="text-align: center;">
            <div class="ring-loader" style="margin: 0 auto;"></div>
            <div class="loader-text">Initializing scene...</div>
        </div>
    </div>

    <div id="ui-container">
        <button id="menu-button">≡</button>

        <div id="settings-menu" class="hidden">
            <h3>Viewer Options</h3>

            <div class="control-row">
                <label title="Use the dark/light theme">Theme</label>

                <select id="theme-select">
                    <option value="0x1a1a1a">Dark</option>
                    <option value="0xd9d9d9">Light</option>
                </select>
            </div>

            <div class="control-row">
                <label title="Show/hide the grid">Show Grid</label>

                <input type="checkbox" id="grid-toggle" checked>
            </div>

            <div class="control-row">
                <label title="Show/hide the orientation cube in the bottom right corner">Orientation Helper Cube</label>

                <input type="checkbox" id="helper-toggle" checked>
            </div>

            <div class="control-row">
                <label title="automatically repositions camera when dimensions change">Show Dimensions</label>

                <input type="checkbox" id="dimensions-toggle" checked>
            </div>

            <div class="control-row">
                <label>Auto Fit View</label>

                <input type="checkbox" id="auto-fit-view-toggle" checked>
            </div>

            <button id="reset-cam">Reset Camera</button>
        </div>
    </div>

    <!-- Use the import map to import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://threejs.org/build/three.module.js",
                "three/addons/": "https://threejs.org/examples/jsm/",
                "libs/": "./libs/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from "three";
        import { STLLoader } from "three/addons/loaders/STLLoader.js";
        import { CSS2DRenderer, CSS2DObject } from "three/addons/renderers/CSS2DRenderer.js";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { ViewHelper } from "three/addons/helpers/ViewHelper.js";
        import { InfiniteGridHelper } from "libs/InfiniteGridHelper.js";

        // Initialize the pybridge
        new QWebChannel(qt.webChannelTransport, function (channel) {
            window.pybridge = channel.objects.pybridge;
        });

        let firstFrameRendered = false;
        let autoFitEnabled = true;
        let scene, camera, renderer, currentMesh;

        const loader = new STLLoader();

        window.scene = scene;
        window.loader = loader;

        // Toggle menu visibility
        const menuButton = document.getElementById('menu-button');
        const menu = document.getElementById('settings-menu');

        menuButton.onclick = () => {
            const isHidden = menu.classList.toggle('hidden');

            menuButton.classList.toggle("is-open", !isHidden);
            menuButton.textContent = isHidden ? '≡' : '×';
        };

        // Reset camera
        document.getElementById('reset-cam').onclick = () => {
            controls.reset();
        };

        // Auto-fit toggle
        document.getElementById("auto-fit-view-toggle").onchange = (e) => {
            autoFitEnabled = e.target.checked;
        }

        // Setup the CSS2D renderer
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = "absolute";
        labelRenderer.domElement.style.top = "0px";
        labelRenderer.domElement.style.pointerEvents = "none";

        document.body.appendChild(labelRenderer.domElement);

        function createMeasurement(start, end, labelText, offsetVector, hexColor = 0xff00ee, globalMax = 10) {
            const group = new THREE.Group();
            group.name = "measurementLabels";

            // Use a non-linear scaleFactor
            const scaleFactor = 0.3 + Math.sqrt(globalMax) * 0.3;

            const dir = new THREE.Vector3().subVectors(end, start).normalize();

            // Calculate the total offset and add extra padding (dependent on the scaleFactor) to push it away from the farthest edge
            const totalOffset = offsetVector.clone().add(offsetVector.clone().normalize().multiplyScalar(scaleFactor));

            // Calculate points with the offset
            const pStart = start.clone().add(totalOffset);
            const pEnd = end.clone().add(totalOffset);

            const distance = pStart.distanceTo(pEnd);

            const coneHeight = scaleFactor;

            // Create the main line (thin cylinder)
            const lineLength = Math.max(0, distance - coneHeight);
            const lineThickness = scaleFactor * 0.04;
            const lineGeo = new THREE.CylinderGeometry(lineThickness, lineThickness, lineLength, 8);
            const lineMat = new THREE.MeshStandardMaterial({ color: hexColor });
            const lineMesh = new THREE.Mesh(lineGeo, lineMat);

            lineMesh.position.copy(pStart).lerp(pEnd, 0.5);
            lineMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
            lineMesh.castShadow = true;

            group.add(lineMesh);

            // Create a smooth cone geometry
            const coneRadius = scaleFactor * 0.3;
            const coneGeo = new THREE.ConeGeometry(coneRadius, coneHeight, 32);
            const coneMat = new THREE.MeshStandardMaterial({ color: hexColor });

            // First cone (at pStart)
            const arrow1 = new THREE.Mesh(coneGeo, coneMat);
            arrow1.position.copy(pStart);

            // Point the tip toward pStart, set it's castShadow to true and move it inward by half it's length
            arrow1.quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), dir);
            arrow1.position.copy(pStart).add(dir.clone().multiplyScalar(coneHeight / 2));
            arrow1.castShadow = true;

            // Second Cone (at pEnd)
            const arrow2 = new THREE.Mesh(coneGeo, coneMat);
            arrow2.position.copy(pEnd);

            // Point the tip toward pEnd, set it's castShadow to true and move it inward by half it's length
            arrow2.quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), dir.clone().negate());
            arrow2.position.copy(pEnd).sub(dir.clone().multiplyScalar(coneHeight / 2));
            arrow2.castShadow = true;

            group.add(arrow1, arrow2);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = 384;
            canvas.height = 192;

            // Background and round rectangle
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.strokeStyle = `#${new THREE.Color(hexColor).getHexString()}`;
            ctx.lineWidth = 8;

            ctx.beginPath();

            if (ctx.roundRect) {
                ctx.roundRect(5, 5, canvas.width - 10, canvas.height - 10, 20);
            } else {
                ctx.rect(5, 5, canvas.width - 10, canvas.height - 10); // Fallback for older browsers
            }

            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = 'white';
            ctx.font = '80px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.fillText(labelText, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, depthTest: true });
            const label = new THREE.Sprite(spriteMat);

            // Calculate center point
            const centerX = (pStart.x + pEnd.x) / 2;
            const centerY = (pStart.y + pEnd.y) / 2;
            const centerZ = (pStart.z + pEnd.z) / 2;

            const labelPos = new THREE.Vector3(centerX, centerY, centerZ);

            // Find the direction of the line
            const lineDir = new THREE.Vector3().subVectors(pEnd, pStart).normalize();

            // We want to push the label "outward" or "upward"
            // If the line is horizontal (X or Z axis), we push it up or out
            // If the line is vertical (Y axis), we push it to the side
            const up = new THREE.Vector3(0, 1, 0);
            let offsetDir = new THREE.Vector3().crossVectors(lineDir, up).normalize();

            // If the line is perfectly vertical, the cross product above fails (0,0,0)
            // So we check if the line is vertical and use a different axis
            if (offsetDir.length() < 0.1) {
                offsetDir.set(1, 0, 0);
            }

            // Calculate the base center
            const center = new THREE.Vector3().lerpVectors(pStart, pEnd, 0.5);

            // Check if the offsetDir is pointing "inward" toward the model
            // 'center' is the middle of the line. If adding offsetDir makes
            // the point closer to the model's center (0,0,0), we flip it.
            const testPos = center.clone().add(offsetDir);
            if (testPos.length() < center.length()) {
                offsetDir.multiplyScalar(-1);
            }

            // Apply the 0.3 offset in the calculated direction
            labelPos.add(offsetDir.multiplyScalar(scaleFactor));

            // Add a small extra Y bump to move the label strictly above the floor
            // labelPos.add(offsetDir.multiplyScalar(scaleFactor * 0.8));
            labelPos.add(offsetDir.multiplyScalar(scaleFactor));
            labelPos.y += scaleFactor * 0.2;

            label.position.copy(labelPos);

            // Calculate the aspect ratio of the canvas (256 / 128 = 2)
            const aspectRatio = canvas.width / canvas.height;

            // Set the Y scale (height) first, then multiply by aspect ratio for X (width)
            const baseHeight = scaleFactor * 1.75;

            label.scale.set(baseHeight * aspectRatio, baseHeight, 1);

            group.add(label);

            scene.add(group);
        }

        function updateMeasurements(mesh, rawSize) {
            // Remove all existing measurement groups
            const toRemove = [];

            scene.traverse((child) => {
                if (child.name === "measurementLabels") {
                    toRemove.push(child);
                }
            });

            toRemove.forEach(child => scene.remove(child));

            // Get the actual visual box (after scaling)
            const visualBox = new THREE.Box3().setFromObject(mesh);

            const scaledSize = new THREE.Vector3();
            visualBox.getSize(scaledSize);

            const gap = scaledSize.y * 0.2;
            const globalMax = Math.max(scaledSize.x, scaledSize.y, scaledSize.z);

            // Re-create the 3 main dimensions
            // Width (X)
            createMeasurement(
                new THREE.Vector3(visualBox.min.x, visualBox.min.y, visualBox.max.z),
                new THREE.Vector3(visualBox.max.x, visualBox.min.y, visualBox.max.z),
                `${Math.round(rawSize.x)}mm`,
                new THREE.Vector3(0, 0, gap),
                0xff0000,
                globalMax
            );

            // Height (Y)
            createMeasurement(
                new THREE.Vector3(visualBox.max.x, visualBox.min.y, visualBox.min.z),
                new THREE.Vector3(visualBox.max.x, visualBox.max.y, visualBox.min.z),
                `${Math.round(rawSize.y)}mm`,
                new THREE.Vector3(gap, 0, -gap),
                0x00ff00,
                globalMax
            );

            // Length (Z)
            createMeasurement(
                new THREE.Vector3(visualBox.max.x, visualBox.min.y, visualBox.min.z),
                new THREE.Vector3(visualBox.max.x, visualBox.min.y, visualBox.max.z),
                `${Math.round(rawSize.z)}mm`,
                new THREE.Vector3(gap, 0, 0),
                0x0000ff,
                globalMax
            );
        }

        // Create a new Three.js scene and set it's background color to a dark gray
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x202020);

        // Create the camera
        camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);

        // Create a new renderer, set it's size to the innerWidth and innerHeight and append it to the document
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Tell renderere not to clear automatically
        renderer.autoClear = false;

        // Initialize ViewHelper
        const viewHelper = new ViewHelper(camera, renderer.domElement);

        document.getElementById('helper-toggle').onchange = (e) => {
            viewHelper.visible = e.target.checked;
        };

        document.getElementById('dimensions-toggle').onchange = (e) => {
            scene.traverse((object) => {
                if (object.name === "measurementLabels") {
                    object.visible = e.target.checked;
                }
            });
        };

        // Add and configure a new ambient light
        scene.add(new THREE.AmbientLight(0xffffff, 0.5))

        // Configure a directional light and add it to the scene
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7.5);

        // Enable shadows in the renderer
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Update your Directional Light to cast shadows
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 50;

        scene.add(dirLight);

        loader.load("./model.stl", geometry => {
            // Load and compute the model.stl file
            geometry.center();
            geometry.computeBoundingBox();

            const size = new THREE.Vector3();
            geometry.boundingBox.getSize(size);

            // Create mesh
            const mesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0xff0000 }))
            currentMesh = mesh;

            // Apply target scale before positioning
            const maxDimensions = Math.max(size.x, size.y, size.z);

            // Shift the geometry up so the bottom is the pivot
            geometry.translate(size.x / 2, size.y / 2, size.z / 2);
            mesh.position.set(0, 0, 0);

            scene.add(mesh);

            // Calculate bounds
            const box = new THREE.Box3().setFromObject(mesh);

            // size1 = 10 (A major line every 10mm (1cm))
            // size2 = 1  (A minor line every 1mm)
            const grid = new InfiniteGridHelper(10, 1, new THREE.Color(0xffffff), 500);
            grid.position.y = -0.001; // Tiny offset to prevent "Z-fighting" (flickering) with the model floor

            document.getElementById("grid-toggle").onchange = (e) => {
                grid.visible = e.target.checked;
            }

            // Theme (background color)
            document.getElementById('theme-select').onchange = (e) => {
                const selectedColor = parseInt(e.target.value);

                scene.background = new THREE.Color(selectedColor);

                if (selectedColor > 0x888888) {
                    grid.setColor(0x333333);
                } else {
                    grid.setColor(0xffffff);
                }
            };

            scene.add(grid);

            const gap = 0.5; // Distance away from farthest edge

            updateMeasurements(currentMesh, size);

            // Camera positioned relative to model size
            const scaleFactor = 2 / maxDimensions;

            controls.update();

            controls.saveState();
            hideLoader();
        }, undefined, e => console.error(e))

        // Handle the resizing of the window
        window.addEventListener("resize", () => {
            camera.aspect = innerWidth / innerHeight;

            camera.updateProjectionMatrix();

            renderer.setSize(innerWidth, innerHeight);
        });

        function hideLoader() {
            const loader = document.getElementById("loader-container");

            setTimeout(() => {
                loader.style.opacity = "0";

                if (window.pybridge) {
                    window.pybridge.on_viewer_ready()
                }

                document.getElementById("menu-button").classList.add("is-ready");

                setTimeout(() => {
                    loader.style.display = 'none';
                }, 800); // Remove from DOM after fade
            }, 300); // Artificial delay
        }

        window.updateMesh = function(url) {
            loader.load(url, function (geometry) {
                // Remove old mesh
                if (currentMesh) {
                    scene.remove(currentMesh);

                    // Remove from memory
                    currentMesh.geometry.dispose();
                    currentMesh.material.dispose();
                }

                const toRemove = [];

                scene.traverse((child) => {
                    if (child.name === "measurementLabels") toRemove.push(child);
                })

                toRemove.forEach(child => scene.remove(child));

                // Setup new geometry
                geometry.center();
                geometry.computeBoundingBox();

                const size = new THREE.Vector3();
                geometry.boundingBox.getSize(size);

                currentMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0xff0000 }));

                const maxDimensions = Math.max(size.x, size.y, size.z);

                geometry.translate(-size.x / 2, size.y / 2, -size.z / 2);
                currentMesh.position.set(0, 0, 0);

                scene.add(currentMesh);

                const newBox = new THREE.Box3().setFromObject(currentMesh);
                const sphere = newBox.getBoundingSphere(new THREE.Sphere());

                if (autoFitEnabled) {
                    const distance = sphere.radius / Math.tan(Math.PI * camera.fov / 360);
                    camera.position.set(distance, distance, distance);
                }

                controls.target.set(0, size.y / 2, 0);
                controls.update();

                // Re-create the measurements with the new size
                updateMeasurements(currentMesh, size);
            }, undefined, function(err) {
                console.error("[viewer.html] Error: ", err);
            });
        };

        // Render the scene
        (function animate() {
            requestAnimationFrame(animate);

            controls.update();

            renderer.clear();

            // Render main scene (full window)
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
            viewHelper.render(renderer);
        })();
    </script>
</body>
</html>
